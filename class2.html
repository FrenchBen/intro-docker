<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

  	<title>Intro to Docker ~ Girl Develop It</title>

    <meta name="description" content="Girl Develop It is partnering with Docker on this beginner-level course, which will introduce you to the Docker platform and take you through installing, integrating, and running Docker in your working environment to make it easier to create, deploy, and run applications by using containers.">
		<meta name="author" content="Girl Develop It">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple.css" id="theme">
    <link rel="stylesheet" href="css/custom.css">

    <!-- For syntax highlighting -->
    <!-- light editor--><link rel="stylesheet" href="lib/css/light.css">
    <!-- dark editor<link rel="stylesheet" href="lib/css/dark.css"> -->
    <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

    <link rel="stylesheet" href="plugin/accessibility-helper/css/accessibility-helper.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!-- If use the PDF print sheet so students can print slides-->

    <link rel="stylesheet" href="css/print/pdf.css" type="text/css" media="print">
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
    <section>
      <img src="img/circle-gdi-logo.png" alt="GDI Logo" class="noborder">
      <h1>Intro to Docker</h1>
      <h2>Class 2</h2>
    </section>

    <!-- Welcome-->
    <section class="hide-pdf">
      <h3>Welcome!</h3>
      <div class = "left-align">
      <p>Girl Develop It is here to provide affordable and accessible programs to learn software through mentorship and hands-on instruction.</p>
      <p class ="green">Some "rules"</p>
      <ul>
        <li>We are here for you!</li>
        <li>Every question is important</li>
        <li>Help each other</li>
        <li>Have fun</li>
      </ul>
      </div>
    </section>


    <!-- Agenda -->
    <section>
      <h3>What we will cover today</h3>
      <ul>
        <li class ="fragment">Building docker images</li>
        <li class ="fragment">Copying files during a build</li>
        <li class ="fragment">Advanced Dockerfiles</li>
        <li class="fragment">Naming &amp; inspecting containers</li>
        <li class="fragment">Compose</li>
        <li class="fragment">Networking</li>
        <li class="fragment">Resources</li>
      </ul>
    </section>

    <section>
      <h3>Building Docker Images</h3>
      <h4>Building Images Interactively</h4>
      <p>As we have seen, the images on the Docker Hub are sometimes very basic.</p>
      <p>How do we want to construct our own images?</p>
      <p>As an example, we will build an image that has figlet.</p>
      <p>First, we will do it manually with docker commit.</p>
      <p>Then later, we will use a Dockerfile and docker build.</p>
    </section>

    <section>
      <h3>Building from a base</h3>
      <p>Our base will be the ubuntu image.</p>
    </section>

    <section>
      <h3>Create a new container and make some changes</h3>
      <p>Start an Ubuntu container:</p>
      <pre><code class = "python">$ docker run -it ubuntu
root@&lt;yourContainerId&gt;:#/</code></pre>
      <p>Run the command apt-get update to refresh the list of packages available to install.</p>
      <p>Then run the command apt-get install figlet to install the program we are interested in.</p>
      <pre><code class = "python">root@5954a4c4e021:#/ apt-get update &amp;&amp; apt-get install figlet
.... OUTPUT OF APT-GET COMMANDS ....</code></pre>
    </section>

    <section>
      <h3>Inspect the changes</h3>
      <p>Type exit at the container prompt to leave the interactive session.</p>
      <p>Now let's run docker diff to see the difference between the base image and our container.</p>
      <pre><code class = "python">$ docker diff &lt;yourContainerId&gt;
C /root
A /root/.bash_history
C /tmp
C /usr
C /usr/bin
A /usr/bin/figlet
...</code></pre>
    </section>

    <section>
      <h3>Docker tracks filesystem changes</h3>
      <p>As we know:</p>
      <ul>
        <li>An image is read-only.</li>
        <li>When we make changes, they happen in a copy of the image.</li>
        <li>Docker can show the difference between the image, and its copy.</li>
        <li>For performance, Docker uses copy-on-write systems.
(i.e. starting a container based on a big image doesn't incur a huge copy.)</li>
      </ul>
    </section>

    <section>
      <h3>Commit and run your image</h3>
      <p>The docker commit command will create a new layer with those changes, and a new image using this new layer.</p>
      <pre><code class = "python">$ docker commit &lt;yourContainerId&gt;
&lt;newImageId&gt;</code></pre>
      <p>The output of the docker commit command will be the ID for your newly created image.</p>
      <p>We can run this image:</p>
      <pre><code class = "python">$ docker run -it &lt;newImageId&gt;
root@fcfb62f0bfde:/# figlet hello
| |__   ___| | | ___
| '_ \ / _ \ | |/ _ \
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/</code></pre>
    </section>

    <section>
      <h3>Tagging images</h3>
      <p>Referring to an image by its ID is not convenient. Let's tag it instead.</p>
      <p>We can use the tag command:</p>
      <pre><code class = "python">$ docker tag &lt;newImageId&gt; figlet</code></pre>
      <p>But we can also specify the tag as an extra argument to commit:</p>
      <pre><code class = "python">$ docker commit &lt;containerId&gt; figlet</code></pre>
      <p>And then run it using its tag:</p>
      <pre><code class = "python">$ docker run -it figlet</code></pre>
    </section>

    <section>
      <h3>What's next?</h3>
      <p>Manual process = bad.</p>
      <p>Automated process = good.</p>
      <p>Next we will learn how to automate the build process by writing a Dockerfile.</p>
    </section>

    <section>
      <h3>Building Images with a Dockerfile</h3>
      <ul>
        <li>A Dockerfile is a build recipe for a Docker image.</li>
        <li>It contains a series of instructions telling Docker how an image is constructed.</li>
        <li>The docker build command builds an image from a Dockerfile.</li>
      </ul>
    </section>

    <section>
      <h3>Writing our first Dockerfile</h3>
      <p>Our Dockerfile must be in a new, empty directory.</p>
      <ol>
        <li>Create a directory to hold our Dockerfile.<pre><code class = "python">$ mkdir myimage</code></pre></li>
        <li>Create a Dockerfile inside this directory.<pre><code class = "python">$ cd myimage
$ vim Dockerfile</code></pre></li>
      </ol>
      <p>Of course, you can use any other editor of your choice.</p>
    </section>

    <section>
      <h3>Type this into our Dockerfile</h3>
      <pre><code class = "python">FROM ubuntu
RUN apt-get update
RUN apt-get install figlet</code></pre>
      <ul>
        <li>FROM indicates the base image for our build.</li>
        <li>Each RUN line will be executed by Docker during the build.</li>
        <li>Our RUN commands must be non-interactive.
(No input can be provided to Docker during the build.)</li>
        <li>In many cases, we will add the -y flag to apt-get.</li>
      </ul>
    </section>

    <section>
      <h3>Build it!</h3>
      <p>Save our file, then execute:</p>
      <pre><code class = "python">$ docker build -t figlet .</code></pre>
      <ul>
        <li>-t indicates the tag to apply to the image.</li>
        <li>. indicates the location of the build context.
(We will talk more about the build context later; but to keep things
simple: this is the directory where our Dockerfile is located.)</li>
      </ul>
    </section>

    <section>
      <h3>What happens when we build the image?</h3>
      <p>The output of docker build looks like this:</p>
      <pre><code class = "python">$ docker build -t figlet .
Sending build context to Docker daemon 2.048 kB
Sending build context to Docker daemon
Step 0 : FROM ubuntu
 ---> e54ca5efa2e9
Step 1 : RUN apt-get update
 ---> Running in 840cb3533193
 ---> 7257c37726a1
Removing intermediate container 840cb3533193
Step 2 : RUN apt-get install figlet
 ---> Running in 2b44df762a2f
 ---> f9e8f1642759
Removing intermediate container 2b44df762a2f
Successfully built f9e8f1642759</code></pre>
      <ul>
        <li>The output of the RUN commands has been omitted.</li>
        <li>Let's explain what this output means.</li>
      </ul>
    </section>

    <section>
      <h3>Sending the build context to Docker</h3>
      <pre><code class = "python">Sending build context to Docker daemon 2.048 kB</code></pre>
      <ul>
        <li>The build context is the . directory given to docker build.</li>
        <li>It is sent (as an archive) by the Docker client to the Docker daemon.</li>
        <li>This allows to use a remote machine to build using local files.</li>
        <li>Be careful (or patient) if that directory is big and your link is slow.</li>
      </ul>
    </section>

    <section>
      <h3>Executing each step</h3>
      <pre><code class = "python">Step 1 : RUN apt-get update
 ---> Running in 840cb3533193
(...output of the RUN command...)
 ---> 7257c37726a1
Removing intermediate container 840cb3533193</code></pre>
      <ul>
        <li>A container (840cb3533193) is created from the base image.</li>
        <li>The RUN command is executed in this container.</li>
        <li>The container is committed into an image (7257c37726a1).</li>
        <li>The build container (840cb3533193) is removed.</li>
        <li>The output of this step will be the base image for the next one.</li>
      </ul>
    </section>

    <section>
      <h3>The caching system</h3>
      <p>If you run the same build again, it will be instantaneous.</p>
      <p>Why?</p>
      <ul>
        <li>After each build step, Docker takes a snapshot of the resulting image.</li>
        <li>Before executing a step, Docker checks if it has already built the same sequence.</li>
        <li>Docker uses the exact strings defined in your Dockerfile, so:
          <ul>
            <li>RUN apt-get install figlet cowsay is different from RUN apt-get install cowsay figlet</li>
            <li>RUN apt-get update is not re-executed when the mirrors are updated</li>
          </ul></li>
      </ul>
      <p>You can force a rebuild with docker build --no-cache</p>
    </section>

    <section>
      <h3>Running the image</h3>
      <p>The resulting image is not different from the one produced manually.</p>
      <pre><code class = "python">$ docker run -ti figlet
root@91f3c974c9a1:/# figlet hello
| |__   ___| | | ___
| '_ \ / _ \ | |/ _ \
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/</code></pre>
      <p>Sweet is the taste of success!</p>
    </section>

    <section>
      <h3>Using image and viewing history</h3>
      <p>The history command lists all the layers composing an image.</p>
      <p>For each layer, it shows its creation time, size, and creation command.</p>
      <p>When an image was built with a Dockerfile, each layer corresponds to a line of the Dockerfile.</p>
      <pre><code class = "python">$ docker history figlet
IMAGE         CREATED            CREATED BY                     SIZE
f9e8f1642759  About an hour ago  /bin/sh -c apt-get install fi  1.627 MB
7257c37726a1  About an hour ago  /bin/sh -c apt-get update      21.58 MB
07c86167cdc4  4 days ago         /bin/sh -c #(nop) CMD ["/bin   0 B
&lt;missing&gt;     4 days ago         /bin/sh -c echo '#!/bin/sh'    194.5 kB</code></pre>
    </section>

    <section>
      <h3>Introducing JSON Syntax</h3>
      <p>Most Dockerfile arguments can be passed in two forms:</p>
      <ul>
        <li>plain string:
      RUN apt-get install figlet</li>
        <li>JSON list:
      RUN ["apt-get", "install", "figlet"]</li>
      <p>Let's change our Dockerfile as follows!</p>
      <pre><code class = "python">FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]</code></pre>
      <p>Then build the new Dockerfile.</p>
      <pre><code class = "python">$ docker build -t figlet .</code></pre>
      </ul>
    </section>

    <section>
      <h3>JSON syntax vs string syntax</h3>
      <p>Compare the new history:</p>
      <pre><code class = "python">$ docker history figlet</code></pre>
      <ul>
        <li>JSON syntax specifies an exact command to execute.</li>
        <li>String syntax specifies a command to be wrapped within /bin/sh -c "...".</li>
      </ul>
    </section>
    <section>
      <h3>The FROM instruction</h3>
      <ul>
        <li>Specifies the source image to build this image.</li>
        <li>Must be the first instruction in the Dockerfile, except for comments.</li>
      </ul>
    </section>

    <section>
      <h3>The FROM instruction</h3>
      <p>Can specify a base image:</p>
      <pre><code class = "python">FROM ubuntu</code></pre>
      <p>An image tagged with a specific version:</p>
      <pre><code class = "python">FROM ubuntu:12.04</code></pre>
      <p>A user image:</p>
      <pre><code class = "python">FROM training/sinatra</code></pre>
      <p>Or self-hosted image:</p>
      <pre><code class = "python">FROM localhost:5000/funtoo</code></pre>
    </section>

    <section>
      <h3>More about FROM</h3>
      <p>The FROM instruction can be specified more than once to build multiple images.</p>
      <pre><code class = "python">FROM ubuntu:14.04 .. .
FROM fedora:20 .. .</code></pre>
      <ul>
        <li>Each FROM instruction marks the beginning of the build of a new image. The -t command-line parameter will only apply to the last image.</li>
        <li>If the build fails, existing tags are left unchanged.</li>
        <li>An optional version tag can be added after the name of the image. E.g.: ubuntu:14.04.</li>
      </ul>
    </section>

    <section>
      <h3>The RUN instruction</h3>
      <p>The RUN instruction can be specified in two ways.</p>
      <p>With shell wrapping, which runs the specified command inside a shell, with /bin/sh -c:</p>
      <pre><code class = "python">RUN apt-get update</code></pre>
      <p>Or using the exec method, which avoids shell string expansion, and allows execution in
images that don't have /bin/sh:</p>
      <pre><code class = "python">RUN [ "apt-get", "update" ]</code></pre>
    </section>

    <section>
      <h3>More about the RUN instruction</h3>
      <h4>RUN will do the following:</h4>
      <ul>
        <li>Execute a command.</li>
        <li>Record changes made to the filesystem.</li>
        <li>Work great to install libraries, packages, and various files.</li>
      </ul>
      <h4>RUN will NOT do the following:</h4>
      <ul>
        <li>Record state of processes. </li>
        <li>Automatically start daemons.</li>
      </ul>
      <p>If you want to start something automatically when the container runs, you should use CMD and/or ENTRYPOINT.</p>
    </section>

    <section>
      <section>
        <h3>ENTRYPOINT vs CMD</h3>
        <p>There are 2 types of commands that a container runs when we type <mark>docker run</mark></p>
        <ul>
          <li class="fragment"><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank">ENTRYPOINT</a>: allows you to configure a container that will run as an executable. (optional)</li>
          <li class="fragment"><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank">CMD</a>: provide defaults for an executing container.</li>
        </ul>
      </section>
      <section class="future">
        <h3>ENTRYPOINT vs CMD (example)</h3>
        <p>Re-using our figlet image, we can add a <mark>CMD</mark></p>
        <pre><code class = "python">FROM ubuntu
RUN apt-get update
RUN apt-get install figlet
CMD ["figlet","hello","world"]</code></pre>
        <p>What happens when you run it?</p>
      </section>
      <section class="future">
        <h3>ENTRYPOINT vs CMD (example)</h3>
        <p>Re-using our figlet image, we can add an <mark>ENTRYPOINT</mark></p>
        <pre><code class = "python">FROM ubuntu
RUN apt-get update
RUN apt-get install figlet
ENTRYPOINT ["figlet"]
CMD ["hello","world"]</code></pre>
        <p>What happens when you run it this time?</p>
      </section>
      <section class="future">
        <h3>ENTRYPOINT vs CMD (example)</h3>
        <p>What did we gain by adding the <mark>ENTRYPOINT</mark>?</p>
        <p>Our "hello world" text became the input to our ENTRYPOINT. <br/>This means that we can pass other text to it.</p>
        <p> Try it out with something like <br/><mark>docker run figlet I love GDI</mark></p>
        <img src="/img/confetti.gif" class="noborder" />
      </section>
    </section>

    <section>
      <h3>Copying the files during the build</h3>
      <p>So far, we have installed things in our container images by downloading packages.</p>
      <p>We can also copy files from the build context to the container that we are building.</p>
      <p><em>Remember:</em> the build context is the directory containing the Dockerfile.</p>
      <p>Next, we will learn a new Dockerfile keyword: COPY.</p>
    </section>

    <section>
      <h3>The COPY instruction</h3>
      <p>The COPY instruction adds files and content from your host into the image.</p>
      <pre><code class = "python">COPY . /src</code></pre>
      <p>This will add the contents of the build context (the directory passed
        as an argument to docker build) to the directory /src in the container.</p>
      <p>Note: you can only reference files and directories inside the build
        context. Absolute paths are taken as being anchored to the build context,
        so the two following lines are equivalent:</p>
      <pre><code class = "python">COPY . /src
COPY / /src</code></pre>
    </section>

    <section>
      <h3>The COPY instruction</h3>
      <p>Attempts to use .. to get out of the build context will be detected and blocked with Docker, and the build will fail.</p>
      <p>Otherwise, a Dockerfile could succeed on host A, but fail on host B.</p>
    </section>

    <section>
      <h3>ADD</h3>
      <p>ADD works almost like COPY, but has a few extra features.</p>
      <p>ADD can get remote files:</p>
      <pre><code class = "python">ADD http://www.example.com/webapp.jar /opt/</code></pre>
      <p>This would download the webapp.jar file and place it in the /opt directory. </p>
      <p>ADD will automatically unpack zip files and tar archives:</p>
      <pre><code class = "python">ADD ./assets.zip /var/www/htdocs/assets/</code></pre>
      <p>This would unpack assets.zip into /var/www/htdocs/assets. However, ADD will not automatically unpack remote archives.</p>
    </section>

    <section>
      <h3>ADD, COPY and the build cache</h3>
      <ul>
        <li>For most Dockerfiles instructions, Docker only checks if the line in the Dockerfile
has changed.</li>
        <li>For ADD and COPY, Docker also checks if the files to be added to the container have been changed.</li>
        <li>ADD always need to download the remote file before it can check if it has been changed. (It cannot use, e.g., ETags or If-Modified-Since headers.)</li>
      </ul>
    </section>

    <section>
      <h3>Build some python code</h3>
      <p>We want to build a container that runs a basic "Hello world" program in python.</p>
      <p>Here is the program, hello.py:</p>
      <pre><code class = "python">print("Hello World.")</code></pre>
      <p>Let's create a new directory, and put this file in there.</p>
      <p>Then we will write the Dockerfile.</p>
    </section>

    <section>
      <h3>The Dockerfile</h3>
      <p>The <a href="https://store.docker.com/images/python" target="_blank">Docker Store</a> has a pre-built image with Python 2.7 in it - Let's use it!</p>
      <p>Then we will use COPY to place the source file into the container.</p>
      <pre><code class = "python">FROM python:2.7
COPY hello.py /
CMD ["python", "/hello.py"]</code></pre>
      <p>Create this Dockerfile.</p>
    </section>

    <section>
      <h3>Testing our python program</h3>
      <ul>
        <li>Create hello.py and Dockerfile in the same directory.</li>
        <li>Run docker build -t hello . in this directory.</li>
        <li>Run <mark>docker run hello</mark>, you should see Hello, world!.</li>
      </ul>
      <p>Success!</p>
    </section>
  
    <section>
      <h3>COPY and the build cache</h3>
      <ul>
        <li>Run the build again.</li>
        <li>Now, modify hello.py and run the build again.</li>
        <li>Docker can cache steps involving COPY.</li>
        <li>Those steps will not be executed again if the files haven't been changed.</li>
      </ul>
    </section>

    <section>
      <h3>Details</h3>
      <ul>
        <li>You can COPY whole directories recursively.</li>
        <li>Older Dockerfiles also have the ADD instruction. It is similar but can automatically extract archives.</li>
      </ul>
    </section>

    <section>
      <h3>Advanced Dockerfiles</h3>
      <h4>Usage Summary</h4>
      <ul>
        <li>Dockerfile instructions are executed in order.</li>
        <li>Each instruction creates a new layer in the image.</li>
        <li>Instructions are cached. If no changes are detected then the instruction is skipped and the cached layer used.</li>
        <li>The FROM instruction MUST be the first non-comment instruction.</li>
        <li>Lines starting with # are treated as comments.</li>
        <li>You can only have one CMD and one ENTRYPOINT instruction in a Dockerfile.</li>
      </ul>
    </section>

    <section>
      <h3>The EXPOSE instruction</h3>
      <p>The EXPOSE instruction tells Docker what ports are to be published in this image.</p>
      <pre><code class = "python">EXPOSE 8080
EXPOSE 80 443
EXPOSE 53/tcp 53/udp</code></pre>
      <ul>
        <li>All ports are private by default.</li>
        <li>The Dockerfile doesn't control if a port is publicly available.</li>
        <li>When you <mark>docker run -p &lt;port&gt; ...</mark>, that port becomes public. (Even if it was not declared with EXPOSE.)</li>
        <li>When you <mark>docker run -P ...</mark> (without port number), all ports declared with EXPOSE become public.</li>
      </ul>
    </section>

    <section>
      <h3>The EXPOSE instruction</h3>
      <p>A <em>public port</em> is reachable from other containers and from outside the host. </p>
      <p>A <em>private port</em> is not reachable from outside.</p>
    </section>
  
    <section>
      <h3>Develop It!</h3>
      <p>Let's deploy a <a href="http://training.play-with-docker.com/webapps/" target="_blank">Simple WebApp</a></p>
      <p>At this point you can copy and paste, without paying too much attention to the details</p>
      <p class="small">Play-With-Docker has <em>vi</em> as it's editor of choice - if you're not familiar with it, you can install <em>nano</em> or <em>emacs</em> via:</p>
      <pre><code class="python">apk add --update nano</code></pre>
    </section>

    <section>
      <section>
        <h3>More Advanced Dockerfile Instructions</h3>
        <ul>
          <li>VOLUME: tells Docker that a specific directory should be a volume.
  </li>
          <li>WORKDIR: sets the working directory for subsequent instructions.</li>
          <li>ENV: specifies environment variables that should be set in any container
  launched from the image.</li>
          <li>USER: sets the user name or UID to use when running the image.</li>
          <li>CMD: a default command run when a container is launched from the
  image.</li>
          <li>ENTRYPOINT: like the CMD instruction, but arguments given on the
  command line are appended to the entry point.</li>
        </ul>
      </section>
      <section class="future">
        <h3>More Advanced Dockerfile Instructions</h3>
        <ul>
          <li>ONBUILD: lets you stash instructions that will be executed when this image is used as a base for another one.</li>
          <li>LABEL: adds arbitrary metadata to the image.</li>
          <li>ARG: defines build-time variables (optional or mandatory).</li>
          <li>STOPSIGNAL: sets the signal for docker stop (TERM by default).</li>
          <li>HEALTHCHECK: defines a command assessing the status of the container.</li>
          <li>SHELL: sets the default program to use for string-syntax RUN, CMD, etc.</li>
        </ul>
        <p>See the Docker <a href="https://docs.docker.com/engine/reference/builder/" target="_blank">Docs</a> for more info.</p>
      </section>
    </section>

    <section>
      <section>
        <h3>How containers communicate</h3>
        <img src="/img/docker-networking.png" class="noborder" />
        <p>When a container is created, it is automatically added to the default docker network for internet access.</p>
        <p>Putting containers on a common network will allow them to communicate.</p>
      </section>
      <section class="future">
        <h3>Containers and Networking</h3>
        <p>Docker includes support for networking containers through the use of <a href="https://docs.docker.com/engine/userguide/networking/" target="_blank">network drivers.</a></p>
        <p>The network named bridge is a special network. Unless you tell it otherwise, Docker always launches your containers in this network.</p>
        <p>For the sake of time, this will be our focus today.</p>
      </section>
    </section>

    
    <section>
      <h3>Viewing networks</h3>
      <p>The <mark>docker network</mark> command is used to list/create/remove networks</p>
      <p>You can view existing networks with:</p>
      <pre><code class = "python">$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
d3ffe2cbbaa0        bridge              bridge              local
b90ba3af1b4c        host                host                local
94227f727e5b        none                null                local 
      </code></pre>
    </section>
    <section>
      <h3>Let&apos;s create our first network!</h3>
      <pre><code class = "python">$ docker network create gdi
8a1f166b588ad95e63f62e950710c34a15c0e0719ca5f35dd5a34019be56663a</code></pre>
      <p>And verify that it was created.</p>
      <pre><code class = "python">$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
d3ffe2cbbaa0        bridge              bridge              local
8a1f166b588a        gdi                 bridge              local
b90ba3af1b4c        host                host                local
94227f727e5b        none                null                local
      </code></pre>
    </section>
    <section>
      <section>
        <h3>Connecting our containers</h3>
        <p>We'll create a simple hello world container and verify that we can talk to it</p>
        <pre><code class = "python">$ docker run -itd --name web --net gdi nginx
  e728c2c6b08bc5203cd1f51fc07e17656e5899b21edcb4345db4f51cd93c2777</code></pre>
        <p><mark>-d</mark> tells Docker to run the image in the background</p>
        <p><mark>--name</mark> specify an easy to remember name for our container</p>
      </section>
      <section class="future">
        <h4>Connecting our containers (cont'd)</h4>
        <p>And create a second container on the same network that will talk to it!</p>
        <pre><code class = "python">$ docker run -it --net gdi frenchben/ping:latest
  root@27a2170f810a:/# ping web
  PING web (172.19.0.2) 56(84) bytes of data.
  64 bytes from web.gdi (172.19.0.2): icmp_seq=1 ttl=64 time=2.98 ms
  64 bytes from web.gdi (172.19.0.2): icmp_seq=2 ttl=64 time=0.061 ms</code></pre>
      </section>
      <section class="future">
        <h4>Connecting our containers (cont'd)</h4>
        <pre><code class = "python">root@27a2170f810a:/# curl http://web
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
  </code></pre>
      </section>
    </section>
    <section>
      <section>
        <h3>Playing with networks</h3>
        <p>We can disconnect our containers from a certain network.</p>
        <pre><code class="python">$ docker network disconnect gdi web</code></pre>
        <p>Re-create the ping container and verify that "web" cannot be reached.</p>
      </section>
      <section class="future">
        <h4>Playing with networks</h4>
        <p>We can also reconnect our containers to a certain network.</p>
        <pre><code class="python">$ docker network connect gdi web</code></pre>
        <p>Re-create the ping container and verify that "web" can be reached again.</p>
        <img src="/img/iam-networking.gif" class="noborder" />
      </section>
    </section>

    <section>
      <h3>Simplifying the process</h3>
      <p>Networking is cool, but all of this typing is annoying and error prone.</p>
      <img src="/img/typing.gif" class="noborder" />
      <p>Let's automate some of this!</p>
    </section>
    <section>
      <section>
        <h3>Why Docker-Compose?</h3>
        <p>Dockerfiles are great to build a single container.</p>
        <p>But when you want to start a complex stack made of multiple containers, you need a different tool. This tool is <a href="https://docs.docker.com/compose/overview/" target="_blank">Docker Compose</a>.</p>
      </section>
      <section class="future">
        <h4>What is Docker Compose?</h4>
        <p>Docker Compose (formerly known as fig) is an external tool.</p>
        <p>It is optional (you do not need Compose to run Docker and containers) but we recommend it highly!</p>
        <p>The general idea of Compose is to enable a very simple, powerful onboarding workflow:</p>
        <ol>
          <li>Clone your code.</li>
          <li>Run docker-compose up.</li>
          <li>Your app is up and running!</li>
        </ol>
      </section>
    </section>
    
    <section>
      <section>
        <h3>Compose Overview</h3>
        <p>This is how you work with Compose:</p>
        <ul>
          <li>You describe a set (or stack) of containers in a YAML file called <em>docker-compose.yml</em>.</li>
          <li>You run docker-compose up.</li>
          <li>Compose automatically pulls images, builds containers, and starts them.</li>
          <li>Compose can set up links, volumes, and other Docker options for you.</li>
          <li>Compose can run the containers in the background, or in the foreground.</li>
          <li>When containers are running in the foreground, their aggregated output is shown.</li>
        </ul>
        <p>Before diving in, let's see a small example of Compose in action.</p>
      </section>
      <section class="future">
        <h4>Compose in action</h4>
        <img src="/img/composeup.gif" class="noborder" />
      </section>
    </section>
      
    <section>
      <section>
        <h3>Let's develop it</h3>
        <p>We are going to create an application that tracks the number of requests.</p>
        <pre><code class="python">$ docker network create dev</code></pre>
        <pre><code class="python">$ docker run --net dev -d -p 5000:5000 frenchben/trainingwheels:latest</code></pre>
        <p><mark>-p</mark> exposes the port 5000 to the host and matches it to port 5000 to container process</p>
      </section>
      <section class="future">
        <p>If we connect to the application now, we will see an error page:</p>
        <img src="/img/trainingwheels-error.png" class="noborder" />
        <p>This is because the Redis service is not running;the container tries to resolve the name <em>redis</em>.</p>
      </section>
      <section class="future">
        <h4>Start the data store</h4>
        <p>We need to start a Redis container.</p>
        <p>That container must be on the same network as the web server.</p>
        <p>It must have the right name (<em>redis</em>) so the application can find it.</p>
        <pre><code class="python">$ docker run --net dev --name redis -d redis</code></pre>
      </section>
      <section class="future">
        <h4>Test the web server again</h4>
        <p>If we connect to the application now, we should see that the app is working correctly:</p>
        <img src="/img/trainingwheels-ok.png" class="noborder" />
        <p>When the app tries to resolve redis, instead of getting a DNS error, it gets the IP address of our Redis container.</p>
      </section>
    </section>
    <section>
      <h3>Our first compose file</h3>
      <p>Create the following <em>docker-compose.yml</em> in a <em>trainingwheels</em> directory:</p> 
      <pre><code class="python">version: '3'

services:
  web:
    image: frenchben/trainingwheels:latest
    ports:
      - 5000:5000
    networks:
      - dev
  redis:
    image: redis
    networks:
      - dev
networks:
  dev:
  </code></pre>
    </section>
    <section>
      <h3>Launching our stack with Docker Compose</h3>
      <pre><code class="python">$ docker-compose up -d</code></pre>
      <p><mark>-d</mark> will create the containers in the background</p>
      <p>Once the containers are up, we can inspect what compose created</p>
      <pre><code class="python">$ docker-compose ps</code></pre>
      <pre><code class="python">$ docker ps</code></pre>
      <pre><code class="python">$ docker network ls</code></pre>
      <p>Notice that all of our resources have the name of our folder in front of them: <em>trainingwheels_</em></p>
    </section>
    <section>
      <h3>Stopping the application</h3>
      <p>To tear down the app, you can gracefully shut it down. Compose will wait 10s for the containers to stop:</p>
      <pre><code class="python">$ docker-compose down</code></pre>
    </section>
    <section>
      <section>
        <h3>Compose file requirements</h3>
        <p>A Docker Compose file has the following required declarations:</p>
        <ul>
          <li><em>version</em>: establishes the version of the file and the sections allowed.</li>
          <li><em>services</em>: declares the services that compose will create.</li>
        </ul>
      </section>
      <section class="future">
        <p>Services will have a name with the following declations: </p>
        <ul>
          <li><em>image</em>: defines the image that the service will use.</li>
        </ul>
        <p>All Compose references can be found within the <a href="https://docs.docker.com/compose/compose-file/" target="_blank">Docker Compose docs</a></p>
      </section>
    </section>
    <section>
      <h3>Docker Volumes</h3>
      <p>If we bring our stack back up you'll notice that the count resets to 0.</p>
      <p>What if we wanted to keep the count even after the stack was torn down? That's when volumes come in handy.</p>
      <p>Volumes exist independently of containers. <br/>They can be listed/created/removed via the <mark>docker volume</mark> command.</p>
      <pre><code class="python">$ docker volume ls
DRIVER              VOLUME NAME
local               e54bc8728936413056fbf2411446477c00...
      </code></pre>
    </section>
    <section>
      <section>
        <h3>Using volumes</h3>
        <p>Volumes can be created without a container, then used in multiple containers. Let's create a volume directly.</p>
        <pre><code class="python">$ docker volume create --name=website
website
$ docker volume ls
DRIVER              VOLUME NAME
local               e54bc8728936413056fbf2411446477c00633f6ad....
local               website
        </code></pre>
      </section>
      <section class="future">
        <h4>Using our named volumes</h4>
        <p>Volumes are used with the <mark>-v</mark> option. When a host path does not contain a /, it is considered to be a volume name.</p>
        <pre><code class="python">$ docker run -d -p 8888:80 -v website:/usr/share/nginx/html nginx
4f49fced8714435d25492e1fffd012760e65....
        </code></pre>
        <p>Verify that nginx is in fact running:</p>
        <pre><code class="python">$ curl localhost:8888</code></pre>
      </section>
      <section class="future">
        <h4>Using our named volumes</h4>
        <p>We can now connect to the same volume using another container and modify the HTML.</p>
        <pre><code class="python">$ docker run -it -v website:/website ubuntu
root@37d7035ada2a:/# cd website/
root@37d7035ada2a:/website# cat index.html
      </code></pre>
      <p>Install an editor of your choice to edit the file and confirm that it's in fact working.</p>
      <pre><code class="python">$ curl localhost:8888</code></pre>
      </section>
    </section>
    <section>
      <h3>Compose and Volumes</h3>
      <p>Back to our original file, we want to save our data! Edit your compose file and add a data volume at the end and a matching one to our redis:</p>
      <pre><code class="python">version: '3'

services:
  web:
    image: frenchben/trainingwheels:latest
    ports:
      - 5000:5000
    networks:
      - dev
  redis:
    image: redis
    command: redis-server --appendonly yes
    networks:
      - dev
    volumes:
      - data-volume:/data
networks:
  dev:
volumes:
  data-volume:
    </code></pre>
    <p><em>command</em>: for redis to use persistent storage we have to overwrite the default <mark>CMD</mark>. <br/>
    This is the equivalent for compose.</p>
    </section>
    <section class="future">
      <h4>Bring the stack up</h4>
      <pre><code class="python">$ docker-compose up</code></pre>
      <p>To stop the application simply hit CTRL + C</p>
      <p>bring it back up again and verify that our request count didn't reset!</p>
      <img src="/img/success.gif" class="noborder" />
  </section>

  <section>
    <h3>Basics CI/CD build in Docker Cloud</h3>
    <h4>Demo by Kristie</h4>
  </section>

  <section data-background="/img/thumbsup.gif">
    <h2>You did it!!!</h2>
    <h3>Questions?</h3>
  </section>

  <section>
    <h3>Resources</h3>
    <ul>
      <li><a href="http://training.play-with-docker.com/" target="_blank">Training via Play-With-Docker</a></li>
      <li><a href="https://github.com/docker/labs/tree/master/networking" target="_blank">Networking with Docker Containers</a> Tutorial</li>
      <li><a href="http://www.docker.com/" target="_blank">Docker homepage</a></li>
      <li><a href="https://store.docker.com" target="_blank">Docker Store</a></li>
      <li><a href="ttp://blog.docker.com/" target="_blank">Docker blog</a></li>
      <li><a href="ttp://docs.docker.com/" target="_blank">Docker documentation</a></li>
    </ul>
  </section>
  <section>
    <h3>Community Resources</h3>
    <ul>
      <li><a href="http://www.docker.com/gettingstarted/" target="_blank">Docker Getting Started Guide</a></li>
      <li><a href="https://github.com/docker/docker" target="_blank">Docker code on GitHub</a></li>
      <li><a href="https://community.docker.com/registrations/groups/4316" target="_blank">Docker Community Slack</a></li>
      <li><a href="https://groups.google.com/forum/#!forum/docker-user" target="_blank">Docker mailing list</a></li>
      <li>Docker on IRC: irc.freenode.net and channels #docker and #docker-dev</li>
      <li>Docker on <a href="http://twitter.com/docker" target="_blank">Twitter</a></li>
      <li>Get Docker help on <a href="http://stackoverflow.com/search?q=docker" target="_blank">Stack Overflow</a></li>
    </ul>
  </section>
  

    
</div><!-- Close slides -->

    <div>
      <footer>
        <div class="copyright">
          HTML/CSS ~ Girl Develop It
          <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/80x15.png" /></a>
        </div>
      </footer>
    </div>
</div><!-- Closes Reveal -->

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/accessibility-helper/js/accessibility-helper.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
